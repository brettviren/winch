* [0/3] todo

- [ ] get ~parent[instance]~ working

  #+begin_example
uv run winch -c wct.toml render -o 'wct/images/{kind}/Containerfile' debian_minimal_da796d15414e08813f6a6c6d81a7f1face282c9f
  #+end_example

- [ ] Tune wct.toml to produce clean ~inode~ and ~anode~

- [ ] add back in ~podman~ code from initial test
  


* Blah blah
  These may have
  parameters that are of type list-of-string.  Such a parameter is interpreted
  as to span all possible variants of that parameter.  For example, a ~debian~
  kind may have parameter ~release~ with values ~bookworm~ and ~trixie~.

- A node represents an "abstract" or "intermediary description of a "kind" of
  container image layer.  A nodes are generated by forming the outer products of
  a parent K node's list-of-string parameters.  If the K node has only scalar
  parameters then it is merely promoted to an A node.

- I node represents a concrete container image layer generated from an A node
  and a possible I node (if the A node itself has a grandparent K node).  Each
  string parameter is interpolated against its other string parameters and
  against its parent A node and possible parent I node parameters.



is modeled as a networkx directed graph with two types of nodes and three types
of edges.  In brief, the two node types are:

- "kind": an abstract parameterization of a container image layer
- "inst": a concrete parameterization of a container image layer

The three edge types represent parentage of container image layers.  That is a
child layer is built upon its parent(s):

- "kind": from one or more parent kind node(s) to one child kind node
- "inst": from one parent inst node to one child inst node
- "made": from one kind node to many generated inst nodes

* Graph nodes and edges

A node may be of type "kind" or "inst".

A "kind" node describes an abstract container image layer.  It is abstract in
two ways.  It may have parameters of type string that contain Python '{format}'
markup.  It may have other parameters of type list-of-string which enumerate
variant values.  These may also contain '{format}' markup.

An "inst" node represents one instance derived from a "kind" node.  Each "kind"
node lead to generating one or more "inst" nodes (associated via "made" edges).
The set of "inst" nodes is generated through a series of outer products over
the following sets of intermediate nodes (not added to the graph):

- The list-of-string parameters in the "kind" node.
- The "inst" nodes of parent kinds.

This produces a final set of intermediate nodes.  The self-formatted operation
is applied to each in this set to produce a final set of "inst" nodes.  This
operation is described below.  A "made" edge is formed from the "kind" node and
each "inst" node and an "inst" edge is formed from each parent inst node and the
inst from which it was generated.  A "kind" edge is formed from each parent kind
to a child kind as determined by that child kind's "parent_kind" parameter.
More details on these relationships are given below.

** Graph and subgraphs

The full graph is a directed graph.  it can be decomposed into subgraphs based
on edge types.  The "kind" subgraph has both splits and joins.  The "inst"
subraph has splits and no joins so is a tree.  As a consequence, there is no
support for multiple FROM in a Container file.  However, a "kind" may be
provided that can meaningfully produce "inst" nodes from more than one parent
kind.

* Outer product parameters

The "kind" node parameters of type list-of-string represent variants.  For
example, the "kind" node of "debian" may have the following parameter (in the
TOML configuration file):

#+begin_example
release = ["bookworm", "trixie"]
#+end_example

This causes the "kind" node "debian" to actually represent two kinds of Debian,
one for each release.  A second parameter may further bifurcate:

#+begin_example
arch = ["amd64", "arm64"]
#+end_example

A "kind" node with both parameters would actually represent four kinds, or
rather would generate four intermediate inst nodes, as described next.

* Generation and parentage

A "kind" node may have zero or more parent "kind" nodes.  An "inst" node has a
single parent "kind" node and zero or one parent "inst" node.  The kind-inst
parentage is represented by a edge in the graph with label "inst".  The inst-inst
parentage has a "pred" (predecessor) label.

The "inst" nodes are generated as a nested outer product.  First, an
intermediate set is generated as the outer product over all list-of-string
parameters in the "kind" node.  Then the set of (full fledged) "inst" nodes of
all nodes given in the "parent_kind" parameter is formed.  An outer product of
these two sets produces a full set of intermediate inst nodes.  Finally, each
intermediate inst node is self-formatted.

* Self format

The self-format operates on a dict.  It attempts to format any string values
using the dict itself.  If a value is a dictionary, self-format recurses.  A
'{format}' markup can only references sibling or child parameters relative to
the parameter being interpolated (eg not parameters at a higher level in the
dict hierarchy or from a cousin branch).  The interpolation iterates until no
more changes are possible.  This will leave any unresolved '{format}' markup in
place.  Unrecognized value types are left as-is.

For example:

#+begin_example
self_format(dict(a='{b}', b=1))
{'a':'1', 'b':1}
#+end_example
Sibling dictionary elements can be refereced

#+begin_example
self_format(dict(a='{b[x]}', b={'x':42}))
{'a':'42', 'b':{'x':42}}
#+end_example
A kind node may use two special dictionaries in its '{format}' markup.  They
represent the fully resolve parameter sets of the parent kind node and the
parent inst node.  They are both empty if the kind node has no parent.

- ~pkind~ the parent kind parameters
- ~ikind~ the parent inst parameters
